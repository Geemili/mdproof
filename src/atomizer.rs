
use std::borrow::Cow;
use cmark::{Parser, Event as ParseEvent, Tag};
use style::{Style, Class};

struct Atomizer<'src> {
    state: AtomizerState<'src>,
    parser: Parser<'src>,
    current_style: Style,
    is_code: bool,
    is_alt_text: bool,
}

enum AtomizerState<'src> {
    /// The atomizer is splitting text apart
    Splitting(Cow<'src, str>),
    /// The atomizer is matching events generated by the markdown parser
    Parsing,
}

enum Event<'src> {
    Atom(Atom<'src>),
    Break(Break),
    StartBlock(BlockTag),
    EndBlock(BlockTag),
}

enum Atom<'src> {
    Text {
        text: Cow<'src, str>,
        style: Style,
    },
    Image {
        uri: Cow<'src, str>,
    },
}

enum Break {
    Line,
    Paragraph,
    HorizontalRule,
    Page,
}

enum BlockTag {
    BlockQuote,
    CodeBlock,
    List(Option<usize>),
    ListItem,
}

impl<'src> Iterator for Atomizer<'src> {
    type Item = Event<'src>;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let state = ::std::mem::replace(&mut self.state, AtomizerState::Parsing);
            let (next_event, next_state) = match state {
                AtomizerState::Parsing => match self.parser.next() {
                    Some(parser_event) => self.parse_event(parser_event),
                    None => break,
                }
                AtomizerState::Splitting(text) => self.split_text(text),
            };
            self.state = next_state;
            if next_event.is_some() {
                return next_event;
            }
        }
        None
    }
}

impl<'src> Atomizer<'src> {
    fn split_text(&mut self, text: Cow<'src, str>) -> (Option<Event<'src>>, AtomizerState<'src>) {
        if text == "" {
            return (None, AtomizerState::Parsing);
        }
        let idx = text
            .find(char::is_whitespace)
            .unwrap_or(text.len());
        // TODO: Figure out if I can keep these COWs borrowed
        let remainder = Cow::Owned(text[idx..].into());
        let text = Cow::Owned(text[..idx].into());
        let style = self.current_style.clone();
        (Some(Event::Atom(Atom::Text { text, style })), AtomizerState::Splitting(remainder))

        /*
        let mut start = 0;
        return (Some(Event::Break(Break::HorizontalRule)), AtomizerState::Parsing)
        for (pos, c) in text.char_indices() {
            if c == '\n' {
                self.write(&text[start..pos]);
                self.new_line();
                start = pos + 1;
            }
        }
        if start < text.len() {
            self.write(&text[start..]);
        }
        */
    }

    fn parse_event(&mut self, event: ParseEvent<'src>) -> (Option<Event<'src>>, AtomizerState<'src>) {
        match event {
            ParseEvent::Start(Tag::Strong) => self.current_style.insert(Class::Strong),
            ParseEvent::End(Tag::Strong) => self.current_style.remove(&Class::Strong),
            ParseEvent::Start(Tag::Emphasis) => self.current_style.insert(Class::Emphasis),
            ParseEvent::End(Tag::Emphasis) => self.current_style.remove(&Class::Emphasis),
            ParseEvent::Start(Tag::Code) => self.current_style.insert(Class::Code),
            ParseEvent::End(Tag::Code) => self.current_style.remove(&Class::Code),


            ParseEvent::Start(Tag::Rule) => return (Some(Event::Break(Break::HorizontalRule)), AtomizerState::Parsing),
            ParseEvent::End(Tag::Rule) => {}

            ParseEvent::Start(Tag::Header(size)) => self.current_style.insert(Class::Heading(size as u8)),
            ParseEvent::End(Tag::Header(size)) => {
                self.current_style.remove(&Class::Heading(size as u8));
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing);
            }

            ParseEvent::Start(Tag::List(first_number)) => return (Some(Event::StartBlock(BlockTag::List(first_number))), AtomizerState::Parsing),
            ParseEvent::End(Tag::List(first_number)) => return (Some(Event::EndBlock(BlockTag::List(first_number))), AtomizerState::Parsing),

            ParseEvent::Start(Tag::Item) => return (Some(Event::StartBlock(BlockTag::ListItem)), AtomizerState::Parsing),
            ParseEvent::End(Tag::Item) => return (Some(Event::StartBlock(BlockTag::ListItem)), AtomizerState::Parsing),

            ParseEvent::Start(Tag::BlockQuote) => return (Some(Event::StartBlock(BlockTag::BlockQuote)), AtomizerState::Parsing),
            ParseEvent::End(Tag::BlockQuote) => return (Some(Event::EndBlock(BlockTag::BlockQuote)), AtomizerState::Parsing),

            ParseEvent::Text(text) => return (None, AtomizerState::Splitting(text)),

            ParseEvent::Html(html) => {
                use scraper::Html;
                let fragment = Html::parse_fragment(&html);

                for value in fragment.tree.values() {
                    let style_option = value.as_element().map(|e| e.attr("style")).unwrap_or(None);
                    match style_option {
                        Some("page-break-after:always;") => {
                            return (Some(Event::Break(Break::Page)), AtomizerState::Parsing);
                        }
                        _ => {}
                    }
                }
            }

            ParseEvent::Start(Tag::Image(uri, _title)) => {
                self.is_alt_text = true;
                return (Some(Event::Atom(Atom::Image { uri })), AtomizerState::Parsing);
            }
            ParseEvent::End(Tag::Image(_url, _title)) => {
                self.is_alt_text = false;
            }

            ParseEvent::Start(Tag::CodeBlock(_src_type)) => {
                self.is_code = true;
                self.current_style.insert(Class::Code);
            }
            ParseEvent::End(Tag::CodeBlock(_)) => {
                self.is_code = false;
                self.current_style.remove(&Class::Code);
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing);
            }

            ParseEvent::Start(Tag::Paragraph) => {}
            ParseEvent::End(Tag::Paragraph) => return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing),

            ParseEvent::SoftBreak => {},
            ParseEvent::HardBreak => return (Some(Event::Break(Break::Line)), AtomizerState::Parsing),

            _ => {}
        };
        (None, AtomizerState::Parsing)
    }
}
